{"meta":{"title":"绿豆的成长日记","subtitle":null,"description":null,"author":"BangWu","url":"http://bangwu.github.io"},"pages":[{"title":"about","date":"2016-05-29T10:42:22.000Z","updated":"2017-10-16T01:18:44.000Z","comments":true,"path":"about/index.html","permalink":"http://bangwu.github.io/about/index.html","excerpt":"","text":""},{"title":"Tags","date":"2017-10-16T01:59:14.554Z","updated":"2017-10-16T01:59:14.552Z","comments":true,"path":"tags/index.html","permalink":"http://bangwu.github.io/tags/index.html","excerpt":"","text":""},{"title":"Categories","date":"2017-10-16T01:58:29.874Z","updated":"2017-10-16T01:58:29.873Z","comments":true,"path":"categories/index.html","permalink":"http://bangwu.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Spring Web应用的最大瑕疵","slug":"spring-web","date":"2016-11-24T00:00:00.000Z","updated":"2017-10-16T02:46:35.417Z","comments":true,"path":"2016/11/24/spring-web/","link":"","permalink":"http://bangwu.github.io/2016/11/24/spring-web/","excerpt":"","text":"Spring Web应用的最大瑕疵众所周知， 现在的Spring框架已经成为构建企业级Java应用事实上的标准了，众多的企业项目都构建在Spring项目及其子项目之上，特别是Java Web项目，很多都使用了Spring并且遵循着Web、Service、Dao这样的分层原则，下层向上层提供服务；不过Petri Kainulainen在其博客中却指出了众多Spring Web应用的最大瑕疵，请继续阅读看看文中所提到的问题是否也出现在你的项目当中 使用Spring框架构建应用的开发者很乐于谈论依赖注入的好处。但遗憾的是，他们很多人并没有在其应用中很好地利用其优势，如单一职责原则和关注分离原则。如果仔细看看基于Spring的Web应用，你会发现很多都是使用如下这些常见且错误的设计原则来实现的： 领域模型对象只是用来存储应用的数据。换句话说，领域模型使用了贫血模型这种反模式。 业务逻辑位于服务层中，管理域对象的数据。 在服务层中，应用的每个实体对应一个服务类。 可问题是：如果这种做法很普遍，那为什么说是不对的呢？下面来阐述一下。 旧习难改Spring Web应用之所以看起来是这个样子原因在于这是人们长久以来的做法，旧习难改，特别是在高级开发者或是软件架构师强制开发人员这样做的时候。问题在于这些人非常擅于捍卫自己的观点。他们喜欢的一个论调就是应用应该遵循关注分离原则，因为它被划分成了几个层次，每个层次都有自己具体的职责。 一个典型的Spring Web应用会有如下几个层次： Web层：负责处理用户的输入并向用户返回正确的响应。Web层只会与服务层通信。 服务层：作为事务边界。它还负责授权并包含了应用的业务逻辑。服务层管理着领域对象模型并且与其他服务及存储层通信。 存储/数据访问层：负责与所用的数据存储进行通信 关注分离原则的定义是这样的：关注分离（Soc）是一种将计算机程序划分到不同部分的一种设计原则，这样每一部分都会有单独的关注点。虽然一个典型的Spring Web应用也在一定程度上遵循了这个原则，不过实际情况却是应用拥有一个整体的服务层，它包含了太多的职责了。更具体一些，服务层主要有两个问题： 首先，应用的业务逻辑来自于服务层。 这是个问题，因为业务逻辑散落在服务层。如果需要查看某个业务规则是如何实现的，我们需要先找到它才行，这可不是那么轻松的事情。此外，如果有多个服务类都需要相同的业务规则，那么开发人员很可能会将这个业务规则从一个服务复制到另一个服务中，这会导致维护的梦魇。 其次，每个领域模型类在服务层中都有一个服务类 这违背了单一职责原则：单一职责原则表明每个类都应该只有一个职责，这个职责应该完全被这个类所封装。它的所有服务都应该与这个职责保持一致。 服务类存在大量的依赖和大量的循环依赖。一个典型的Spring Web应用的服务层没有包含只拥有一个职责的松耦合的服务，它更像是一个紧耦合的大量服务的集合。这使得它很难理解、维护与重用。看起来有点苛刻，不过服务层经常是Spring Web应用最容易出现问题的一环。幸好对我们来说还存在着希望。 推翻目前的状况并不好，不过也不是完全没有希望的。下面我们来看看如何打破旧有的习惯。 首先，我们需要将应用的业务逻辑从服务层移动到领域模型类中 为何要这么做呢，看看下面这个例子： 假设我是个服务类，你是个领域模型对象。如果我告诉你从房顶跳下来，那么你是否会拒绝呢？ 将服务层的业务逻辑移动到领域模型类中有如下3个好处： 根据合理的方式划分代码的职责。服务层会负责应用的逻辑，而领域模型类则负责业务逻辑。 应用的业务逻辑只会位于一处。如果需要验证特定的业务规则是如何实现的，我们总是知道该去哪里寻找。 服务层的源代码将会变得更加整洁，再不会包含任何复制粘贴的代码了。 其次，我们需要将特定于实体的服务划分为更小的服务，每个服务只有一个目标。 比如说，如果应用有一个服务类，它为与用户帐户相关的人与操作提供了CRUD操作，那么我们就应该将其划分到两个单独的服务类中： 第1个服务提供人的CRUD操作。 第2个服务提供与用户帐户相关的操作。 这么做有如下3个好处： 每个服务类都有一套合理的职责。 每个服务类的依赖会更少，这意味着他们不再是紧耦合的庞然大物了。他们是更加小巧且松耦合的组件。 服务类更易于理解、维护与重用。 这两个简单的步骤可以帮助我们清理应用的架构，提升开发者的生产力和幸福度。现在，我们想知道如果所有这些都是必要的，那么该何时解决这些问题呢？ 有时生命是黑白的我经常听到有人说我们不应该过多的关注于“架构”，因为我们的应用很小并且很简单。虽然这个论调有一定的正确性，不过我们必须要记住一开始很小的项目最后会变得很大。如果不考虑这种情况，那么一旦发生状况，我们就会陷入到巨大的麻烦当中。在未知的水域中航行可不是个好做法，但我们必须要知道，泰坦尼克号在撞到冰山沉没时是在熟悉的航线中航行的。这种事情也会发生在我们的应用中。当事情变得无法控制时，我们必须要有勇气说不。 如果你打算改变，那么我推荐你阅读一下Olivier Gierke所写的“Whoops! Where did my architecture”（或是观看他在SpringOne2GX上关于这个项目的演讲）。但请注意，习惯的力量还是很强大的。 原文出自 Spring Web应用的最大瑕疵","categories":[{"name":"Java","slug":"Java","permalink":"http://bangwu.github.io/categories/Java/"}],"tags":[{"name":"Spring MVC","slug":"Spring-MVC","permalink":"http://bangwu.github.io/tags/Spring-MVC/"}]},{"title":"CSS style guide","slug":"css-style","date":"2016-08-06T00:00:00.000Z","updated":"2017-10-16T02:43:52.085Z","comments":true,"path":"2016/08/06/css-style/","link":"","permalink":"http://bangwu.github.io/2016/08/06/css-style/","excerpt":"","text":"Airbnb CSS / Sass 指南用更合理的方式写 CSS 和 Sass 术语 规则声明我们把一个（或一组）选择器和一组属性称之为 “规则声明”。举个例子： 1234.listing &#123; font-size: 18px; line-height: 1.2;&#125; 选择器在规则声明中，“选择器” 负责选取 DOM 树中的元素，这些元素将被定义的属性所修饰。选择器可以匹配 HTML 元素，也可以匹配一个元素的类名、ID, 或者元素拥有的属性。以下是选择器的例子： 1234567.my-element-class &#123; /* ... */&#125;[aria-hidden] &#123; /* ... */&#125; 属性最后，属性决定了规则声明里被选择的元素将得到何种样式。属性以键值对形式存在，一个规则声明可以包含一或多个属性定义。以下是属性定义的例子： 1234/* some selector */ &#123; background: #f1f1f1; color: #333;&#125; CSS 格式 使用 2 个空格作为缩进。 类名建议使用破折号代替驼峰法。如果你使用 BEM，也可以使用下划线（参见下面的 OOCSS 和 BEM）。 不要使用 ID 选择器。 在一个规则声明中应用了多个选择器时，每个选择器独占一行。 在规则声明的左大括号 { 前加上一个空格。 在属性的冒号 : 后面加上一个空格，前面不加空格。 规则声明的右大括号 } 独占一行。 规则声明之间用空行分隔开。 Bad 123456789.avatar&#123; border-radius:50%; border:2px solid white; &#125;.no, .nope, .not_good &#123; // ...&#125;#lol-no &#123; // ...&#125; Good 12345678910.avatar &#123; border-radius: 50%; border: 2px solid white;&#125;.one,.selector,.per-line &#123; // ...&#125; 注释 建议使用行注释 (在 Sass 中是 //) 代替块注释。 建议注释独占一行。避免行末注释。 给没有自注释的代码写上详细说明，比如： 为什么用到了 z-index 兼容性处理或者针对特定浏览器的 hack OOCSS 和 BEM出于以下原因，我们鼓励使用 OOCSS 和 BEM 的某种组合： 可以帮助我们理清 CSS 和 HTML 之间清晰且严谨的关系。 可以帮助我们创建出可重用、易装配的组件。 可以减少嵌套，降低特定性。 可以帮助我们创建出可扩展的样式表。 OOCSS，也就是 “Object Oriented CSS（面向对象的CSS）”，是一种写 CSS 的方法，其思想就是鼓励你把样式表看作“对象”的集合：创建可重用性、可重复性的代码段让你可以在整个网站中多次使用。 参考资料： Nicole Sullivan 的 OOCSS wiki Smashing Magazine 的 Introduction to OOCSS BEM，也就是 “Block-Element-Modifier”，是一种用于 HTML 和 CSS 类名的命名约定。BEM 最初是由 Yandex 提出的，要知道他们拥有巨大的代码库和可伸缩性，BEM 就是为此而生的，并且可以作为一套遵循 OOCSS 的参考指导规范。 CSS Trick 的 BEM 101 Harry Roberts 的 introduction to BEM 示例 123456789&lt;article class=\"listing-card listing-card--featured\"&gt; &lt;h1 class=\"listing-card__title\"&gt;Adorable 2BR in the sunny Mission&lt;/h1&gt; &lt;div class=\"listing-card__content\"&gt; &lt;p&gt;Vestibulum id ligula porta felis euismod semper.&lt;/p&gt; &lt;/div&gt;&lt;/article&gt; 1234.listing-card &#123; &#125;.listing-card--featured &#123; &#125;.listing-card__title &#123; &#125;.listing-card__content &#123; &#125; .listing-card 是一个块（block），表示高层次的组件。 .listing-card__title 是一个元素（element），它属于 .listing-card 的一部分，因此块是由元素组成的。 .listing-card--featured 是一个修饰符（modifier），表示这个块与 .listing-card 有着不同的状态或者变化。 ID 选择器在 CSS 中，虽然可以通过 ID 选择元素，但大家通常都会把这种方式列为反面教材。ID 选择器给你的规则声明带来了不必要的高优先级，而且 ID 选择器是不可重用的。 想要了解关于这个主题的更多内容，参见 CSS Wizardry 的文章，文章中有关于如何处理优先级的内容。 JavaScript 钩子避免在 CSS 和 JavaScript 中绑定相同的类。否则开发者在重构时通常会出现以下情况：轻则浪费时间在对照查找每个要改变的类，重则因为害怕破坏功能而不敢作出更改。 我们推荐在创建用于特定 JavaScript 的类名时，添加 .js- 前缀： 1&lt;button class=\"btn btn-primary js-request-to-book\"&gt;Request to Book&lt;/button&gt; 边框在定义无边框样式时，使用 0 代替 none。 Bad 123.foo &#123; border: none;&#125; Good 123.foo &#123; border: 0;&#125; Sass 语法 使用 .scss 的语法，不使用 .sass 原本的语法。 CSS 和 @include 声明按照以下逻辑排序（参见下文） 属性声明的排序 属性声明 首先列出除去 @include 和嵌套选择器之外的所有属性声明。 12345.btn-green &#123; background: green; font-weight: bold; // ...&#125; @include 声明 紧随后面的是 @include，这样可以使得整个选择器的可读性更高。 123456.btn-green &#123; background: green; font-weight: bold; @include transition(background 0.5s ease); // ...&#125; 嵌套选择器 如果有必要用到嵌套选择器，把它们放到最后，在规则声明和嵌套选择器之间要加上空白，相邻嵌套选择器之间也要加上空白。嵌套选择器中的内容也要遵循上述指引。 123456789.btn &#123; background: green; font-weight: bold; @include transition(background 0.5s ease); .icon &#123; margin-right: 10px; &#125;&#125; 变量变量名应使用破折号（例如 $my-variable）代替 camelCased 和 snake_cased 风格。对于仅用在当前文件的变量，可以在变量名之前添加下划线前缀（例如 $_my-variable）。 Mixins为了让代码遵循 DRY 原则（Don’t Repeat Yourself）、增强清晰性或抽象化复杂性，应该使用 mixin，这与那些命名良好的函数的作用是异曲同工的。虽然 mixin 可以不接收参数，但要注意，假如你不压缩负载（比如通过 gzip），这样会导致最终的样式包含不必要的代码重复。 扩展指令应避免使用 @extend 指令，因为它并不直观，而且具有潜在风险，特别是用在嵌套选择器的时候。即便是在顶层占位符选择器使用扩展，如果选择器的顺序最终会改变，也可能会导致问题。（比如，如果它们存在于其他文件，而加载顺序发生了变化）。其实，使用 @extend 所获得的大部分优化效果，gzip 压缩已经帮助你做到了，因此你只需要通过 mixin 让样式表更符合 DRY 原则就足够了。 嵌套选择器请不要让嵌套选择器的深度超过 3 层！ 1234567.page-container &#123; .content &#123; .profile &#123; // STOP! &#125; &#125;&#125; 当遇到以上情况的时候，你也许是这样写 CSS 的： 与 HTML 强耦合的（也是脆弱的）—或者— 过于具体（强大）—或者— 没有重用 再说一遍: 永远不要嵌套 ID 选择器！ 如果你始终坚持要使用 ID 选择器（劝你三思），那也不应该嵌套它们。如果你正打算这么做，你需要先重新检查你的标签，或者指明原因。如果你想要写出风格良好的 HTML 和 CSS，你是不应该这样做的。 原文出自 Zhangjd / css-style-guide 翻译自 Airbnb CSS / Sass Styleguide","categories":[{"name":"前端","slug":"前端","permalink":"http://bangwu.github.io/categories/前端/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://bangwu.github.io/tags/CSS/"}]},{"title":"Create you own ebook","slug":"create-ebook","date":"2016-05-31T00:00:00.000Z","updated":"2017-10-16T02:43:52.070Z","comments":true,"path":"2016/05/31/create-ebook/","link":"","permalink":"http://bangwu.github.io/2016/05/31/create-ebook/","excerpt":"","text":"在我们的生活中，有时我们需要把一个gitbook点子书转换成pdf,epub或者mobi等格式的文档，我们可以通过下面的方式来完成这件事。 下载你要转换的文档 你可以从gitbook上下载任何一个你想要转换的电子书。 你可以通过以下步骤创建你自己的点子书 install Calibre add it to your path: 1$ ln -s /Applications/calibre.app/Contents/MacOS/ebook-convert /usr/local/bin install gitbook using npm: 1$ npm install gitbook-cli -g in the root folder of your Redux clone (e.g. ~/repositories/redux/), run: 123$ gitbook pdf . docs/redux-documentation.pdf$ gitbook epub . docs/redux-documentation.epub$ gitbook mobi . docs/redux-documentation.mobi I use the create-docs script from this repository and run it in a clone of the official Redux repository.","categories":[{"name":"工具","slug":"工具","permalink":"http://bangwu.github.io/categories/工具/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://bangwu.github.io/tags/JavaScript/"}]},{"title":"Javascript style guide","slug":"code-style","date":"2016-05-30T00:00:00.000Z","updated":"2017-10-16T02:46:35.422Z","comments":true,"path":"2016/05/30/code-style/","link":"","permalink":"http://bangwu.github.io/2016/05/30/code-style/","excerpt":"","text":"写了这么长时间的JavaScript，总结一下如何写出优雅的JavaScript代码，本文章的内容很多来自Airbab，如果想了解更过知识，请参考Airbab Airbnb JavaScript Style Guide() {A mostly reasonable approach to JavaScript Other Style Guides ES5 (Deprecated) React CSS &amp; Sass Ruby Types 1.1 Primitives: When you access a primitive type you work directly on its value. string number boolean null undefined 123456const foo = 1;let bar = foo;bar = 9;console.log(foo, bar); // =&gt; 1, 9 1.2 Complex: When you access a complex type you work on a reference to its value. object array function 123456const foo = [1, 2];const bar = foo;bar[0] = 9;console.log(foo[0], bar[0]); // =&gt; 9, 9 ⬆ back to top References 2.1 Use const for all of your references; avoid using var. eslint: prefer-const, no-const-assign Why? This ensures that you can’t reassign your references, which can lead to bugs and difficult to comprehend code. 1234567// badvar a = 1;var b = 2;// goodconst a = 1;const b = 2; 2.2 If you must reassign references, use let instead of var. eslint: no-var jscs: disallowVar Why? let is block-scoped rather than function-scoped like var. 1234567891011// badvar count = 1;if (true) &#123; count += 1;&#125;// good, use the let.let count = 1;if (true) &#123; count += 1;&#125; 2.3 Note that both let and const are block-scoped. 1234567// const and let only exist in the blocks they are defined in.&#123; let a = 1; const b = 1;&#125;console.log(a); // ReferenceErrorconsole.log(b); // ReferenceError ⬆ back to top Objects 3.1 Use the literal syntax for object creation. eslint: no-new-object 12345// badconst item = new Object();// goodconst item = &#123;&#125;; 3.4 Use computed property names when creating objects with dynamic property names. Why? They allow you to define all the properties of an object in one place. 123456789101112131415161718function getKey(k) &#123; return `a key named $&#123;k&#125;`;&#125;// badconst obj = &#123; id: 5, name: 'San Francisco',&#125;;obj[getKey('enabled')] = true;// goodconst obj = &#123; id: 5, name: 'San Francisco', [getKey('enabled')]: true,&#125;; 3.5 Use object method shorthand. eslint: object-shorthand jscs: requireEnhancedObjectLiterals 1234567891011121314151617// badconst atom = &#123; value: 1, addValue: function (value) &#123; return atom.value + value; &#125;,&#125;;// goodconst atom = &#123; value: 1, addValue(value) &#123; return atom.value + value; &#125;,&#125;; 3.6 Use property value shorthand. eslint: object-shorthand jscs: requireEnhancedObjectLiterals Why? It is shorter to write and descriptive. 1234567891011const lukeSkywalker = 'Luke Skywalker';// badconst obj = &#123; lukeSkywalker: lukeSkywalker,&#125;;// goodconst obj = &#123; lukeSkywalker,&#125;; 3.7 Group your shorthand properties at the beginning of your object declaration. Why? It’s easier to tell which properties are using the shorthand. 12345678910111213141516171819202122const anakinSkywalker = 'Anakin Skywalker';const lukeSkywalker = 'Luke Skywalker';// badconst obj = &#123; episodeOne: 1, twoJediWalkIntoACantina: 2, lukeSkywalker, episodeThree: 3, mayTheFourth: 4, anakinSkywalker,&#125;;// goodconst obj = &#123; lukeSkywalker, anakinSkywalker, episodeOne: 1, twoJediWalkIntoACantina: 2, episodeThree: 3, mayTheFourth: 4,&#125;; 3.8 Only quote properties that are invalid identifiers. eslint: quote-props jscs: disallowQuotedKeysInObjects Why? In general we consider it subjectively easier to read. It improves syntax highlighting, and is also more easily optimized by many JS engines. 12345678910111213// badconst bad = &#123; 'foo': 3, 'bar': 4, 'data-blah': 5,&#125;;// goodconst good = &#123; foo: 3, bar: 4, 'data-blah': 5,&#125;; 3.9 Do not call Object.prototype methods directly, such as hasOwnProperty, propertyIsEnumerable, and isPrototypeOf. Why? These methods may be shadowed by properties on the object in question - consider { hasOwnProperty: false } - or, the object may be a null object (Object.create(null)). 123456789101112// badconsole.log(object.hasOwnProperty(key));// goodconsole.log(Object.prototype.hasOwnProperty.call(object, key));// bestconst has = Object.prototype.hasOwnProperty; // cache the lookup once, in module scope./* or */const has = require('has');…console.log(has.call(object, key)); ⬆ back to top Arrays 4.1 Use the literal syntax for array creation. eslint: no-array-constructor 12345// badconst items = new Array();// goodconst items = []; 4.2 Use Array#push instead of direct assignment to add items to an array. 1234567const someStack = [];// badsomeStack[someStack.length] = 'abracadabra';// goodsomeStack.push('abracadabra'); 4.3 Use array spreads ... to copy arrays. 1234567891011// badconst len = items.length;const itemsCopy = [];let i;for (i = 0; i &lt; len; i++) &#123; itemsCopy[i] = items[i];&#125;// goodconst itemsCopy = [...items]; 4.4 To convert an array-like object to an array, use Array.from. 12const foo = document.querySelectorAll('.foo');const nodes = Array.from(foo); 4.5 Use return statements in array method callbacks. It’s ok to omit the return if the function body consists of a single statement following 8.2. eslint: array-callback-return 12345678910111213141516171819202122232425262728293031323334353637383940414243// good[1, 2, 3].map((x) =&gt; &#123; const y = x + 1; return x * y;&#125;);// good[1, 2, 3].map(x =&gt; x + 1);// badconst flat = &#123;&#125;;[[0, 1], [2, 3], [4, 5]].reduce((memo, item, index) =&gt; &#123; const flatten = memo.concat(item); flat[index] = flatten;&#125;);// goodconst flat = &#123;&#125;;[[0, 1], [2, 3], [4, 5]].reduce((memo, item, index) =&gt; &#123; const flatten = memo.concat(item); flat[index] = flatten; return flatten;&#125;);// badinbox.filter((msg) =&gt; &#123; const &#123; subject, author &#125; = msg; if (subject === 'Mockingbird') &#123; return author === 'Harper Lee'; &#125; else &#123; return false; &#125;&#125;);// goodinbox.filter((msg) =&gt; &#123; const &#123; subject, author &#125; = msg; if (subject === 'Mockingbird') &#123; return author === 'Harper Lee'; &#125; return false;&#125;); ⬆ back to top Destructuring 5.1 Use object destructuring when accessing and using multiple properties of an object. jscs: requireObjectDestructuring Why? Destructuring saves you from creating temporary references for those properties. 123456789101112131415161718// badfunction getFullName(user) &#123; const firstName = user.firstName; const lastName = user.lastName; return `$&#123;firstName&#125; $&#123;lastName&#125;`;&#125;// goodfunction getFullName(user) &#123; const &#123; firstName, lastName &#125; = user; return `$&#123;firstName&#125; $&#123;lastName&#125;`;&#125;// bestfunction getFullName(&#123; firstName, lastName &#125;) &#123; return `$&#123;firstName&#125; $&#123;lastName&#125;`;&#125; 5.2 Use array destructuring. jscs: requireArrayDestructuring 12345678const arr = [1, 2, 3, 4];// badconst first = arr[0];const second = arr[1];// goodconst [first, second] = arr; 5.3 Use object destructuring for multiple return values, not array destructuring. jscs: disallowArrayDestructuringReturn Why? You can add new properties over time or change the order of things without breaking call sites. 1234567891011121314151617// badfunction processInput(input) &#123; // then a miracle occurs return [left, right, top, bottom];&#125;// the caller needs to think about the order of return dataconst [left, __, top] = processInput(input);// goodfunction processInput(input) &#123; // then a miracle occurs return &#123; left, right, top, bottom &#125;;&#125;// the caller selects only the data they needconst &#123; left, top &#125; = processInput(input); ⬆ back to top Strings 6.1 Use single quotes &#39;&#39; for strings. eslint: quotes jscs: validateQuoteMarks 12345678// badconst name = \"Capt. Janeway\";// bad - template literals should contain interpolation or newlinesconst name = `Capt. Janeway`;// goodconst name = 'Capt. Janeway'; 6.2 Strings that cause the line to go over 100 characters should not be written across multiple lines using string concatenation. Why? Broken strings are painful to work with and make code less searchable. 12345678910111213// badconst errorMessage = 'This is a super long error that was thrown because \\of Batman. When you stop to think about how Batman had anything to do \\with this, you would get nowhere \\fast.';// badconst errorMessage = 'This is a super long error that was thrown because ' + 'of Batman. When you stop to think about how Batman had anything to do ' + 'with this, you would get nowhere fast.';// goodconst errorMessage = 'This is a super long error that was thrown because of Batman. When you stop to think about how Batman had anything to do with this, you would get nowhere fast.'; 6.4 When programmatically building up strings, use template strings instead of concatenation. eslint: prefer-template template-curly-spacing jscs: requireTemplateStrings Why? Template strings give you a readable, concise syntax with proper newlines and string interpolation features. 12345678910111213141516171819// badfunction sayHi(name) &#123; return 'How are you, ' + name + '?';&#125;// badfunction sayHi(name) &#123; return ['How are you, ', name, '?'].join();&#125;// badfunction sayHi(name) &#123; return `How are you, $&#123; name &#125;?`;&#125;// goodfunction sayHi(name) &#123; return `How are you, $&#123;name&#125;?`;&#125; 6.5 Never use eval() on a string, it opens too many vulnerabilities. 6.6 Do not unnecessarily escape characters in strings. eslint: no-useless-escape Why? Backslashes harm readability, thus they should only be present when necessary. 123456// badconst foo = '\\'this\\' \\i\\s \\\"quoted\\\"';// goodconst foo = '\\'this\\' is \"quoted\"';const foo = `'this' is \"quoted\"`; ⬆ back to top Functions 7.1 Use function declarations instead of function expressions. eslint: func-style jscs: requireFunctionDeclarations Why? Function declarations are named, so they’re easier to identify in call stacks. Also, the whole body of a function declaration is hoisted, whereas only the reference of a function expression is hoisted. This rule makes it possible to always use Arrow Functions in place of function expressions. 1234567// badconst foo = function () &#123;&#125;;// goodfunction foo() &#123;&#125; 7.2 Wrap immediately invoked function expressions in parentheses. eslint: wrap-iife jscs: requireParenthesesAroundIIFE Why? An immediately invoked function expression is a single unit - wrapping both it, and its invocation parens, in parens, cleanly expresses this. Note that in a world with modules everywhere, you almost never need an IIFE. 1234// immediately-invoked function expression (IIFE)(function () &#123; console.log('Welcome to the Internet. Please follow me.');&#125;()); 7.3 Never declare a function in a non-function block (if, while, etc). Assign the function to a variable instead. Browsers will allow you to do it, but they all interpret it differently, which is bad news bears. eslint: no-loop-func 7.4 Note: ECMA-262 defines a block as a list of statements. A function declaration is not a statement. Read ECMA-262’s note on this issue. 1234567891011121314// badif (currentUser) &#123; function test() &#123; console.log('Nope.'); &#125;&#125;// goodlet test;if (currentUser) &#123; test = () =&gt; &#123; console.log('Yup.'); &#125;;&#125; 7.5 Never name a parameter arguments. This will take precedence over the arguments object that is given to every function scope. 123456789// badfunction nope(name, options, arguments) &#123; // ...stuff...&#125;// goodfunction yup(name, options, args) &#123; // ...stuff...&#125; 7.6 Never use arguments, opt to use rest syntax ... instead. eslint: prefer-rest-params Why? ... is explicit about which arguments you want pulled. Plus, rest arguments are a real Array, and not merely Array-like like arguments. 12345678910// badfunction concatenateAll() &#123; const args = Array.prototype.slice.call(arguments); return args.join('');&#125;// goodfunction concatenateAll(...args) &#123; return args.join('');&#125; 7.7 Use default parameter syntax rather than mutating function arguments. 123456789101112131415161718192021// really badfunction handleThings(opts) &#123; // No! We shouldn't mutate function arguments. // Double bad: if opts is falsy it'll be set to an object which may // be what you want but it can introduce subtle bugs. opts = opts || &#123;&#125;; // ...&#125;// still badfunction handleThings(opts) &#123; if (opts === void 0) &#123; opts = &#123;&#125;; &#125; // ...&#125;// goodfunction handleThings(opts = &#123;&#125;) &#123; // ...&#125; 7.8 Avoid side effects with default parameters. Why? They are confusing to reason about. 123456789var b = 1;// badfunction count(a = b++) &#123; console.log(a);&#125;count(); // 1count(); // 2count(3); // 3count(); // 3 7.9 Always put default parameters last. 123456789// badfunction handleThings(opts = &#123;&#125;, name) &#123; // ...&#125;// goodfunction handleThings(name, opts = &#123;&#125;) &#123; // ...&#125; 7.10 Never use the Function constructor to create a new function. eslint: no-new-func Why? Creating a function in this way evaluates a string similarly to eval(), which opens vulnerabilities. 12345// badvar add = new Function('a', 'b', 'return a + b');// still badvar subtract = Function('a', 'b', 'return a - b'); 7.11 Spacing in a function signature. eslint: space-before-function-paren space-before-blocks Why? Consistency is good, and you shouldn’t have to add or remove a space when adding or removing a name. 12345678// badconst f = function()&#123;&#125;;const g = function ()&#123;&#125;;const h = function() &#123;&#125;;// goodconst x = function () &#123;&#125;;const y = function a() &#123;&#125;; 7.12 Never mutate parameters. eslint: no-param-reassign Why? Manipulating objects passed in as parameters can cause unwanted variable side effects in the original caller. 123456789// badfunction f1(obj) &#123; obj.key = 1;&#125;;// goodfunction f2(obj) &#123; const key = Object.prototype.hasOwnProperty.call(obj, 'key') ? obj.key : 1;&#125;; 7.13 Never reassign parameters. eslint: no-param-reassign Why? Reassigning parameters can lead to unexpected behavior, especially when accessing the arguments object. It can also cause optimization issues, especially in V8. 12345678910111213141516// badfunction f1(a) &#123; a = 1;&#125;function f2(a) &#123; if (!a) &#123; a = 1; &#125;&#125;// goodfunction f3(a) &#123; const b = a || 1;&#125;function f4(a = 1) &#123;&#125; 7.14 Prefer the use of the spread operator ... to call variadic functions. eslint: prefer-spread Why? It’s cleaner, you don’t need to supply a context, and you can not easily compose new with apply. 12345678910111213// badconst x = [1, 2, 3, 4, 5];console.log.apply(console, x);// goodconst x = [1, 2, 3, 4, 5];console.log(...x);// badnew (Function.prototype.bind.apply(Date, [null, 2016, 08, 05]));// goodnew Date(...[2016, 08, 05]); ⬆ back to top Arrow Functions 8.1 When you must use function expressions (as when passing an anonymous function), use arrow function notation. eslint: prefer-arrow-callback, arrow-spacing jscs: requireArrowFunctions Why? It creates a version of the function that executes in the context of this, which is usually what you want, and is a more concise syntax. Why not? If you have a fairly complicated function, you might move that logic out into its own function declaration. 1234567891011// bad[1, 2, 3].map(function (x) &#123; const y = x + 1; return x * y;&#125;);// good[1, 2, 3].map((x) =&gt; &#123; const y = x + 1; return x * y;&#125;); 8.2 If the function body consists of a single expression, omit the braces and use the implicit return. Otherwise, keep the braces and use a return statement. eslint: arrow-parens, arrow-body-style jscs: disallowParenthesesAroundArrowParam, requireShorthandArrowFunctions Why? Syntactic sugar. It reads well when multiple functions are chained together. 12345678910111213141516171819// bad[1, 2, 3].map(number =&gt; &#123; const nextNumber = number + 1; `A string containing the $&#123;nextNumber&#125;.`;&#125;);// good[1, 2, 3].map(number =&gt; `A string containing the $&#123;number&#125;.`);// good[1, 2, 3].map((number) =&gt; &#123; const nextNumber = number + 1; return `A string containing the $&#123;nextNumber&#125;.`;&#125;);// good[1, 2, 3].map((number, index) =&gt; (&#123; index: number&#125;)); 8.3 In case the expression spans over multiple lines, wrap it in parentheses for better readability. Why? It shows clearly where the function starts and ends. 1234567891011// bad[1, 2, 3].map(number =&gt; 'As time went by, the string containing the ' + `$&#123;number&#125; became much longer. So we needed to break it over multiple ` + 'lines.');// good[1, 2, 3].map(number =&gt; ( `As time went by, the string containing the $&#123;number&#125; became much ` + 'longer. So we needed to break it over multiple lines.')); 8.4 If your function takes a single argument and doesn’t use braces, omit the parentheses. Otherwise, always include parentheses around arguments. eslint: arrow-parens jscs: disallowParenthesesAroundArrowParam Why? Less visual clutter. 1234567891011121314151617181920212223// bad[1, 2, 3].map((x) =&gt; x * x);// good[1, 2, 3].map(x =&gt; x * x);// good[1, 2, 3].map(number =&gt; ( `A long string with the $&#123;number&#125;. It’s so long that we’ve broken it ` + 'over multiple lines!'));// bad[1, 2, 3].map(x =&gt; &#123; const y = x + 1; return x * y;&#125;);// good[1, 2, 3].map((x) =&gt; &#123; const y = x + 1; return x * y;&#125;); 8.5 Avoid confusing arrow function syntax (=&gt;) with comparison operators (&lt;=, &gt;=). eslint: no-confusing-arrow 1234567891011121314// badconst itemHeight = item =&gt; item.height &gt; 256 ? item.largeSize : item.smallSize;// badconst itemHeight = (item) =&gt; item.height &gt; 256 ? item.largeSize : item.smallSize;// goodconst itemHeight = item =&gt; (item.height &gt; 256 ? item.largeSize : item.smallSize);// goodconst itemHeight = (item) =&gt; &#123; const &#123; height, largeSize, smallSize &#125; = item; return height &gt; 256 ? largeSize : smallSize;&#125;; ⬆ back to top Classes &amp; Constructors 9.1 Always use class. Avoid manipulating prototype directly. Why? class syntax is more concise and easier to reason about. 12345678910111213141516171819202122// badfunction Queue(contents = []) &#123; this.queue = [...contents];&#125;Queue.prototype.pop = function () &#123; const value = this.queue[0]; this.queue.splice(0, 1); return value;&#125;;// goodclass Queue &#123; constructor(contents = []) &#123; this.queue = [...contents]; &#125; pop() &#123; const value = this.queue[0]; this.queue.splice(0, 1); return value; &#125;&#125; 9.2 Use extends for inheritance. Why? It is a built-in way to inherit prototype functionality without breaking instanceof. 12345678910111213141516// badconst inherits = require('inherits');function PeekableQueue(contents) &#123; Queue.apply(this, contents);&#125;inherits(PeekableQueue, Queue);PeekableQueue.prototype.peek = function () &#123; return this._queue[0];&#125;// goodclass PeekableQueue extends Queue &#123; peek() &#123; return this._queue[0]; &#125;&#125; 9.3 Methods can return this to help with method chaining. 12345678910111213141516171819202122232425262728293031// badJedi.prototype.jump = function () &#123; this.jumping = true; return true;&#125;;Jedi.prototype.setHeight = function (height) &#123; this.height = height;&#125;;const luke = new Jedi();luke.jump(); // =&gt; trueluke.setHeight(20); // =&gt; undefined// goodclass Jedi &#123; jump() &#123; this.jumping = true; return this; &#125; setHeight(height) &#123; this.height = height; return this; &#125;&#125;const luke = new Jedi();luke.jump() .setHeight(20); 9.4 It’s okay to write a custom toString() method, just make sure it works successfully and causes no side effects. 12345678910111213class Jedi &#123; constructor(options = &#123;&#125;) &#123; this.name = options.name || 'no name'; &#125; getName() &#123; return this.name; &#125; toString() &#123; return `Jedi - $&#123;this.getName()&#125;`; &#125;&#125; 9.5 Classes have a default constructor if one is not specified. An empty constructor function or one that just delegates to a parent class is unnecessary. eslint: no-useless-constructor 1234567891011121314151617181920212223// badclass Jedi &#123; constructor() &#123;&#125; getName() &#123; return this.name; &#125;&#125;// badclass Rey extends Jedi &#123; constructor(...args) &#123; super(...args); &#125;&#125;// goodclass Rey extends Jedi &#123; constructor(...args) &#123; super(...args); this.name = 'Rey'; &#125;&#125; 9.6 Avoid duplicate class members. eslint: no-dupe-class-members Why? Duplicate class member declarations will silently prefer the last one - having duplicates is almost certainly a bug. 123456789101112131415// badclass Foo &#123; bar() &#123; return 1; &#125; bar() &#123; return 2; &#125;&#125;// goodclass Foo &#123; bar() &#123; return 1; &#125;&#125;// goodclass Foo &#123; bar() &#123; return 2; &#125;&#125; ⬆ back to top Modules 10.1 Always use modules (import/export) over a non-standard module system. You can always transpile to your preferred module system. Why? Modules are the future, let’s start using the future now. 1234567891011// badconst AirbnbStyleGuide = require('./AirbnbStyleGuide');module.exports = AirbnbStyleGuide.es6;// okimport AirbnbStyleGuide from './AirbnbStyleGuide';export default AirbnbStyleGuide.es6;// bestimport &#123; es6 &#125; from './AirbnbStyleGuide';export default es6; 10.2 Do not use wildcard imports. Why? This makes sure you have a single default export. 12345// badimport * as AirbnbStyleGuide from './AirbnbStyleGuide';// goodimport AirbnbStyleGuide from './AirbnbStyleGuide'; 10.3 And do not export directly from an import. Why? Although the one-liner is concise, having one clear way to import and one clear way to export makes things consistent. 12345678// bad// filename es6.jsexport &#123; es6 as default &#125; from './airbnbStyleGuide';// good// filename es6.jsimport &#123; es6 &#125; from './AirbnbStyleGuide';export default es6; 10.4 Only import from a path in one place.eslint: no-duplicate-imports Why? Having multiple lines that import from the same path can make code harder to maintain. 12345678910111213// badimport foo from 'foo';// … some other imports … //import &#123; named1, named2 &#125; from 'foo';// goodimport foo, &#123; named1, named2 &#125; from 'foo';// goodimport foo, &#123; named1, named2,&#125; from 'foo'; 10.5 Do not export mutable bindings.eslint: import/no-mutable-exports Why? Mutation should be avoided in general, but in particular when exporting mutable bindings. While this technique may be needed for some special cases, in general, only constant references should be exported. 1234567// badlet foo = 3;export &#123; foo &#125;// goodconst foo = 3;export &#123; foo &#125; 10.6 In modules with a single export, prefer default export over named export.eslint: import/prefer-default-export 12345// badexport function foo() &#123;&#125;// goodexport default function foo() &#123;&#125; 10.7 Put all imports above non-import statements.eslint: import/imports-first Why? Since imports are hoisted, keeping them all at the top prevents surprising behavior. 1234567891011// badimport foo from 'foo';foo.init();import bar from 'bar';// goodimport foo from 'foo';import bar from 'bar';foo.init(); ⬆ back to top Iterators and Generators 11.1 Don’t use iterators. Prefer JavaScript’s higher-order functions instead of loops like for-in or for-of. eslint: no-iterator no-restricted-syntax Why? This enforces our immutable rule. Dealing with pure functions that return values is easier to reason about than side effects. Use map() / every() / filter() / find() / findIndex() / reduce() / some() / … to iterate over arrays, and Object.keys() / Object.values() / Object.entries() to produce arrays so you can iterate over objects. 123456789101112131415161718const numbers = [1, 2, 3, 4, 5];// badlet sum = 0;for (let num of numbers) &#123; sum += num;&#125;sum === 15;// goodlet sum = 0;numbers.forEach(num =&gt; sum += num);sum === 15;// best (use the functional force)const sum = numbers.reduce((total, num) =&gt; total + num, 0);sum === 15; 11.2 Don’t use generators for now. Why? They don’t transpile well to ES5. 11.3 If you must use generators, or if you disregard our advice, make sure their function signature is spaced properly. eslint: generator-star-spacing Why? function and * are part of the same conceptual keyword - * is not a modifier for function, function* is a unique construct, different from function. 123456789101112131415161718192021222324252627282930313233343536// badfunction * foo() &#123;&#125;const bar = function * () &#123;&#125;const baz = function *() &#123;&#125;const quux = function*() &#123;&#125;function*foo() &#123;&#125;function *foo() &#123;&#125;// very badfunction*foo() &#123;&#125;const wat = function*() &#123;&#125;// goodfunction* foo() &#123;&#125;const foo = function* () &#123;&#125; ⬆ back to top Properties 12.1 Use dot notation when accessing properties. eslint: dot-notation jscs: requireDotNotation 12345678910const luke = &#123; jedi: true, age: 28,&#125;;// badconst isJedi = luke['jedi'];// goodconst isJedi = luke.jedi; 12.2 Use bracket notation [] when accessing properties with a variable. 12345678910const luke = &#123; jedi: true, age: 28,&#125;;function getProp(prop) &#123; return luke[prop];&#125;const isJedi = getProp('jedi'); ⬆ back to top Variables 13.1 Always use const to declare variables. Not doing so will result in global variables. We want to avoid polluting the global namespace. Captain Planet warned us of that. eslint: no-undef prefer-const 12345// badsuperPower = new SuperPower();// goodconst superPower = new SuperPower(); 13.2 Use one const declaration per variable. eslint: one-var jscs: disallowMultipleVarDecl Why? It’s easier to add new variable declarations this way, and you never have to worry about swapping out a ; for a , or introducing punctuation-only diffs. You can also step through each declaration with the debugger, instead of jumping through all of them at once. 123456789101112131415// badconst items = getItems(), goSportsTeam = true, dragonball = 'z';// bad// (compare to above, and try to spot the mistake)const items = getItems(), goSportsTeam = true; dragonball = 'z';// goodconst items = getItems();const goSportsTeam = true;const dragonball = 'z'; 13.3 Group all your consts and then group all your lets. Why? This is helpful when later on you might need to assign a variable depending on one of the previous assigned variables. 123456789101112131415161718// badlet i, len, dragonball, items = getItems(), goSportsTeam = true;// badlet i;const items = getItems();let dragonball;const goSportsTeam = true;let len;// goodconst goSportsTeam = true;const items = getItems();let dragonball;let i;let length; 13.4 Assign variables where you need them, but place them in a reasonable place. Why? let and const are block scoped and not function scoped. 12345678910111213141516171819202122232425262728293031// bad - unnecessary function callfunction checkName(hasName) &#123; const name = getName(); if (hasName === 'test') &#123; return false; &#125; if (name === 'test') &#123; this.setName(''); return false; &#125; return name;&#125;// goodfunction checkName(hasName) &#123; if (hasName === 'test') &#123; return false; &#125; const name = getName(); if (name === 'test') &#123; this.setName(''); return false; &#125; return name;&#125; ⬆ back to top Hoisting 14.1 var declarations get hoisted to the top of their scope, their assignment does not. const and let declarations are blessed with a new concept called Temporal Dead Zones (TDZ). It’s important to know why typeof is no longer safe. 123456789101112131415161718192021222324252627282930// we know this wouldn't work (assuming there// is no notDefined global variable)function example() &#123; console.log(notDefined); // =&gt; throws a ReferenceError&#125;// creating a variable declaration after you// reference the variable will work due to// variable hoisting. Note: the assignment// value of `true` is not hoisted.function example() &#123; console.log(declaredButNotAssigned); // =&gt; undefined var declaredButNotAssigned = true;&#125;// the interpreter is hoisting the variable// declaration to the top of the scope,// which means our example could be rewritten as:function example() &#123; let declaredButNotAssigned; console.log(declaredButNotAssigned); // =&gt; undefined declaredButNotAssigned = true;&#125;// using const and letfunction example() &#123; console.log(declaredButNotAssigned); // =&gt; throws a ReferenceError console.log(typeof declaredButNotAssigned); // =&gt; throws a ReferenceError const declaredButNotAssigned = true;&#125; 14.2 Anonymous function expressions hoist their variable name, but not the function assignment. 123456789function example() &#123; console.log(anonymous); // =&gt; undefined anonymous(); // =&gt; TypeError anonymous is not a function var anonymous = function () &#123; console.log('anonymous function expression'); &#125;;&#125; 14.3 Named function expressions hoist the variable name, not the function name or the function body. 1234567891011121314151617181920212223function example() &#123; console.log(named); // =&gt; undefined named(); // =&gt; TypeError named is not a function superPower(); // =&gt; ReferenceError superPower is not defined var named = function superPower() &#123; console.log('Flying'); &#125;;&#125;// the same is true when the function name// is the same as the variable name.function example() &#123; console.log(named); // =&gt; undefined named(); // =&gt; TypeError named is not a function var named = function named() &#123; console.log('named'); &#125;&#125; 14.4 Function declarations hoist their name and the function body. 1234567function example() &#123; superPower(); // =&gt; Flying function superPower() &#123; console.log('Flying'); &#125;&#125; For more information refer to JavaScript Scoping &amp; Hoisting by Ben Cherry. ⬆ back to top Comparison Operators &amp; Equality 15.1 Use === and !== over == and !=. eslint: eqeqeq 15.2 Conditional statements such as the if statement evaluate their expression using coercion with the ToBoolean abstract method and always follow these simple rules: Objects evaluate to true Undefined evaluates to false Null evaluates to false Booleans evaluate to the value of the boolean Numbers evaluate to false if +0, -0, or NaN, otherwise true Strings evaluate to false if an empty string &#39;&#39;, otherwise true 1234if ([0] &amp;&amp; []) &#123; // true // an array (even an empty one) is an object, objects will evaluate to true&#125; 15.3 Use shortcuts. 12345678910111213141516171819// badif (name !== '') &#123; // ...stuff...&#125;// goodif (name) &#123; // ...stuff...&#125;// badif (collection.length &gt; 0) &#123; // ...stuff...&#125;// goodif (collection.length) &#123; // ...stuff...&#125; 15.4 For more information see Truth Equality and JavaScript by Angus Croll. 15.5 Use braces to create blocks in case and default clauses that contain lexical declarations (e.g. let, const, function, and class). Why? Lexical declarations are visible in the entire switch block but only get initialized when assigned, which only happens when its case is reached. This causes problems when multiple case clauses attempt to define the same thing. eslint rules: no-case-declarations. 123456789101112131415161718192021222324252627282930313233343536// badswitch (foo) &#123; case 1: let x = 1; break; case 2: const y = 2; break; case 3: function f() &#123;&#125; break; default: class C &#123;&#125;&#125;// goodswitch (foo) &#123; case 1: &#123; let x = 1; break; &#125; case 2: &#123; const y = 2; break; &#125; case 3: &#123; function f() &#123;&#125; break; &#125; case 4: bar(); break; default: &#123; class C &#123;&#125; &#125;&#125; 15.6 Ternaries should not be nested and generally be single line expressions. eslint rules: no-nested-ternary. 12345678910111213141516// badconst foo = maybe1 &gt; maybe2 ? \"bar\" : value1 &gt; value2 ? \"baz\" : null;// betterconst maybeNull = value1 &gt; value2 ? 'baz' : null;const foo = maybe1 &gt; maybe2 ? 'bar' : maybeNull;// bestconst maybeNull = value1 &gt; value2 ? 'baz' : null;const foo = maybe1 &gt; maybe2 ? 'bar' : maybeNull; 15.7 Avoid unneeded ternary statements. eslint rules: no-unneeded-ternary. 123456789// badconst foo = a ? a : b;const bar = c ? true : false;const baz = c ? false : true;// goodconst foo = a || b;const bar = !!c;const baz = !c; ⬆ back to top Blocks 16.1 Use braces with all multi-line blocks. 12345678910111213141516171819// badif (test) return false;// goodif (test) return false;// goodif (test) &#123; return false;&#125;// badfunction foo() &#123; return false; &#125;// goodfunction bar() &#123; return false;&#125; 16.2 If you’re using multi-line blocks with if and else, put else on the same line as your if block’s closing brace. eslint: brace-style jscs: disallowNewlineBeforeBlockStatements 12345678910111213141516// badif (test) &#123; thing1(); thing2();&#125;else &#123; thing3();&#125;// goodif (test) &#123; thing1(); thing2();&#125; else &#123; thing3();&#125; ⬆ back to top Comments 17.1 Use /** ... */ for multi-line comments. Include a description, specify types and values for all parameters and return values. 123456789101112131415161718192021222324252627// bad// make() returns a new element// based on the passed in tag name//// @param &#123;String&#125; tag// @return &#123;Element&#125; elementfunction make(tag) &#123; // ...stuff... return element;&#125;// good/** * make() returns a new element * based on the passed in tag name * * @param &#123;String&#125; tag * @return &#123;Element&#125; element */function make(tag) &#123; // ...stuff... return element;&#125; 17.2 Use // for single line comments. Place single line comments on a newline above the subject of the comment. Put an empty line before the comment unless it’s on the first line of a block. 123456789101112131415161718192021222324252627282930313233// badconst active = true; // is current tab// good// is current tabconst active = true;// badfunction getType() &#123; console.log('fetching type...'); // set the default type to 'no type' const type = this._type || 'no type'; return type;&#125;// goodfunction getType() &#123; console.log('fetching type...'); // set the default type to 'no type' const type = this._type || 'no type'; return type;&#125;// also goodfunction getType() &#123; // set the default type to 'no type' const type = this._type || 'no type'; return type;&#125; 17.3 Prefixing your comments with FIXME or TODO helps other developers quickly understand if you’re pointing out a problem that needs to be revisited, or if you’re suggesting a solution to the problem that needs to be implemented. These are different than regular comments because they are actionable. The actions are FIXME: -- need to figure this out or TODO: -- need to implement. 17.4 Use // FIXME: to annotate problems. 12345678class Calculator extends Abacus &#123; constructor() &#123; super(); // FIXME: shouldn't use a global here total = 0; &#125;&#125; 17.5 Use // TODO: to annotate solutions to problems. 12345678class Calculator extends Abacus &#123; constructor() &#123; super(); // TODO: total should be configurable by an options param this.total = 0; &#125;&#125; ⬆ back to top Whitespace 18.1 Use soft tabs set to 2 spaces. eslint: indent jscs: validateIndentation 1234567891011121314// badfunction foo() &#123;∙∙∙∙const name;&#125;// badfunction bar() &#123;∙const name;&#125;// goodfunction baz() &#123;∙∙const name;&#125; 18.2 Place 1 space before the leading brace. eslint: space-before-blocks jscs: requireSpaceBeforeBlockStatements 123456789101112131415161718192021// badfunction test()&#123; console.log('test');&#125;// goodfunction test() &#123; console.log('test');&#125;// baddog.set('attr',&#123; age: '1 year', breed: 'Bernese Mountain Dog',&#125;);// gooddog.set('attr', &#123; age: '1 year', breed: 'Bernese Mountain Dog',&#125;); 18.3 Place 1 space before the opening parenthesis in control statements (if, while etc.). Place no space between the argument list and the function name in function calls and declarations. eslint: keyword-spacing jscs: requireSpaceAfterKeywords 12345678910111213141516171819// badif(isJedi) &#123; fight ();&#125;// goodif (isJedi) &#123; fight();&#125;// badfunction fight () &#123; console.log ('Swooosh!');&#125;// goodfunction fight() &#123; console.log('Swooosh!');&#125; 18.4 Set off operators with spaces. eslint: space-infix-ops jscs: requireSpaceBeforeBinaryOperators, requireSpaceAfterBinaryOperators 12345// badconst x=y+5;// goodconst x = y + 5; 18.5 End files with a single newline character. eslint: eol-last 1234// bad(function (global) &#123; // ...stuff...&#125;)(this); 12345// bad(function (global) &#123; // ...stuff...&#125;)(this);↵↵ 1234// good(function (global) &#123; // ...stuff...&#125;)(this);↵ 18.6 Use indentation when making long method chains (more than 2 method chains). Use a leading dot, whichemphasizes that the line is a method call, not a new statement. eslint: newline-per-chained-call no-whitespace-before-property 12345678910111213141516171819202122232425262728293031323334353637// bad$('#items').find('.selected').highlight().end().find('.open').updateCount();// bad$('#items'). find('.selected'). highlight(). end(). find('.open'). updateCount();// good$('#items') .find('.selected') .highlight() .end() .find('.open') .updateCount();// badconst leds = stage.selectAll('.led').data(data).enter().append('svg:svg').classed('led', true) .attr('width', (radius + margin) * 2).append('svg:g') .attr('transform', 'translate(' + (radius + margin) + ',' + (radius + margin) + ')') .call(tron.led);// goodconst leds = stage.selectAll('.led') .data(data) .enter().append('svg:svg') .classed('led', true) .attr('width', (radius + margin) * 2) .append('svg:g') .attr('transform', 'translate(' + (radius + margin) + ',' + (radius + margin) + ')') .call(tron.led);// goodconst leds = stage.selectAll('.led').data(data); 18.7 Leave a blank line after blocks and before the next statement. jscs: requirePaddingNewLinesAfterBlocks 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// badif (foo) &#123; return bar;&#125;return baz;// goodif (foo) &#123; return bar;&#125;return baz;// badconst obj = &#123; foo() &#123; &#125;, bar() &#123; &#125;,&#125;;return obj;// goodconst obj = &#123; foo() &#123; &#125;, bar() &#123; &#125;,&#125;;return obj;// badconst arr = [ function foo() &#123; &#125;, function bar() &#123; &#125;,];return arr;// goodconst arr = [ function foo() &#123; &#125;, function bar() &#123; &#125;,];return arr; 18.8 Do not pad your blocks with blank lines. eslint: padded-blocks jscs: disallowPaddingNewlinesInBlocks 123456789101112131415161718192021222324252627// badfunction bar() &#123; console.log(foo);&#125;// also badif (baz) &#123; console.log(qux);&#125; else &#123; console.log(foo);&#125;// goodfunction bar() &#123; console.log(foo);&#125;// goodif (baz) &#123; console.log(qux);&#125; else &#123; console.log(foo);&#125; 18.9 Do not add spaces inside parentheses. eslint: space-in-parens jscs: disallowSpacesInsideParentheses 12345678910111213141516171819// badfunction bar( foo ) &#123; return foo;&#125;// goodfunction bar(foo) &#123; return foo;&#125;// badif ( foo ) &#123; console.log(foo);&#125;// goodif (foo) &#123; console.log(foo);&#125; 18.10 Do not add spaces inside brackets. eslint: array-bracket-spacing jscs: disallowSpacesInsideArrayBrackets 1234567// badconst foo = [ 1, 2, 3 ];console.log(foo[ 0 ]);// goodconst foo = [1, 2, 3];console.log(foo[0]); 18.11 Add spaces inside curly braces. eslint: object-curly-spacing jscs: requireSpacesInsideObjectBrackets 12345// badconst foo = &#123;clark: 'kent'&#125;;// goodconst foo = &#123; clark: 'kent' &#125;; 18.12 Avoid having lines of code that are longer than 100 characters (including whitespace). eslint: max-len jscs: maximumLineLength Why? This ensures readability and maintainability. 123456789101112131415161718// badconst foo = 'Whatever national crop flips the window. The cartoon reverts within the screw. Whatever wizard constrains a helpful ally. The counterpart ascends!';// bad$.ajax(&#123; method: 'POST', url: 'https://airbnb.com/', data: &#123; name: 'John' &#125; &#125;).done(() =&gt; console.log('Congratulations!')).fail(() =&gt; console.log('You have failed this city.'));// goodconst foo = 'Whatever national crop flips the window. The cartoon reverts within the screw. ' + 'Whatever wizard constrains a helpful ally. The counterpart ascends!';// good$.ajax(&#123; method: 'POST', url: 'https://airbnb.com/', data: &#123; name: 'John' &#125;,&#125;) .done(() =&gt; console.log('Congratulations!')) .fail(() =&gt; console.log('You have failed this city.')); ⬆ back to top Commas 19.1 Leading commas: Nope. eslint: comma-style jscs: requireCommaBeforeLineBreak 1234567891011121314151617181920212223242526272829// badconst story = [ once , upon , aTime];// goodconst story = [ once, upon, aTime,];// badconst hero = &#123; firstName: 'Ada' , lastName: 'Lovelace' , birthYear: 1815 , superPower: 'computers'&#125;;// goodconst hero = &#123; firstName: 'Ada', lastName: 'Lovelace', birthYear: 1815, superPower: 'computers',&#125;; 19.2 Additional trailing comma: Yup. eslint: comma-dangle jscs: requireTrailingComma Why? This leads to cleaner git diffs. Also, transpilers like Babel will remove the additional trailing comma in the transpiled code which means you don’t have to worry about the trailing comma problem in legacy browsers. 123456789101112131415161718192021222324252627282930313233343536// bad - git diff without trailing commaconst hero = &#123; firstName: 'Florence',- lastName: 'Nightingale'+ lastName: 'Nightingale',+ inventorOf: ['coxcomb chart', 'modern nursing']&#125;;// good - git diff with trailing commaconst hero = &#123; firstName: 'Florence', lastName: 'Nightingale',+ inventorOf: ['coxcomb chart', 'modern nursing'],&#125;;// badconst hero = &#123; firstName: 'Dana', lastName: 'Scully'&#125;;const heroes = [ 'Batman', 'Superman'];// goodconst hero = &#123; firstName: 'Dana', lastName: 'Scully',&#125;;const heroes = [ 'Batman', 'Superman',]; ⬆ back to top Semicolons 20.1 Yup. eslint: semi jscs: requireSemicolons 1234567891011121314151617// bad(function () &#123; const name = 'Skywalker' return name&#125;)()// good(function () &#123; const name = 'Skywalker'; return name;&#125;());// good, but legacy (guards against the function becoming an argument when two files with IIFEs are concatenated);(() =&gt; &#123; const name = 'Skywalker'; return name;&#125;()); Read more. ⬆ back to top Type Casting &amp; Coercion 21.1 Perform type coercion at the beginning of the statement. 21.2 Strings: 12345678910// =&gt; this.reviewScore = 9;// badconst totalScore = this.reviewScore + ''; // invokes this.reviewScore.valueOf()// badconst totalScore = this.reviewScore.toString(); // isn't guaranteed to return a string// goodconst totalScore = String(this.reviewScore); 21.3 Numbers: Use Number for type casting and parseInt always with a radix for parsing strings. eslint: radix 12345678910111213141516171819const inputValue = '4';// badconst val = new Number(inputValue);// badconst val = +inputValue;// badconst val = inputValue &gt;&gt; 0;// badconst val = parseInt(inputValue);// goodconst val = Number(inputValue);// goodconst val = parseInt(inputValue, 10); 21.4 If for whatever reason you are doing something wild and parseInt is your bottleneck and need to use Bitshift for performance reasons, leave a comment explaining why and what you’re doing. 1234567// good/** * parseInt was the reason my code was slow. * Bitshifting the String to coerce it to a * Number made it a lot faster. */const val = inputValue &gt;&gt; 0; 21.5 Note: Be careful when using bitshift operations. Numbers are represented as 64-bit values, but bitshift operations always return a 32-bit integer (source). Bitshift can lead to unexpected behavior for integer values larger than 32 bits. Discussion. Largest signed 32-bit Int is 2,147,483,647: 1232147483647 &gt;&gt; 0 //=&gt; 21474836472147483648 &gt;&gt; 0 //=&gt; -21474836482147483649 &gt;&gt; 0 //=&gt; -2147483647 21.6 Booleans: 12345678910const age = 0;// badconst hasAge = new Boolean(age);// goodconst hasAge = Boolean(age);// bestconst hasAge = !!age; ⬆ back to top Naming Conventions 22.1 Avoid single letter names. Be descriptive with your naming. eslint: id-length 123456789// badfunction q() &#123; // ...stuff...&#125;// goodfunction query() &#123; // ..stuff..&#125; 22.2 Use camelCase when naming objects, functions, and instances. eslint: camelcase jscs: requireCamelCaseOrUpperCaseIdentifiers 12345678// badconst OBJEcttsssss = &#123;&#125;;const this_is_my_object = &#123;&#125;;function c() &#123;&#125;// goodconst thisIsMyObject = &#123;&#125;;function thisIsMyFunction() &#123;&#125; 22.3 Use PascalCase only when naming constructors or classes. eslint: new-cap jscs: requireCapitalizedConstructors 12345678910111213141516171819// badfunction user(options) &#123; this.name = options.name;&#125;const bad = new user(&#123; name: 'nope',&#125;);// goodclass User &#123; constructor(options) &#123; this.name = options.name; &#125;&#125;const good = new User(&#123; name: 'yup',&#125;); 22.4 Do not use trailing or leading underscores. eslint: no-underscore-dangle jscs: disallowDanglingUnderscores Why? JavaScript does not have the concept of privacy in terms of properties or methods. Although a leading underscore is a common convention to mean “private”, in fact, these properties are fully public, and as such, are part of your public API contract. This convention might lead developers to wrongly think that a change won’t count as breaking, or that tests aren’t needed. tl;dr: if you want something to be “private”, it must not be observably present. 1234567// badthis.__firstName__ = 'Panda';this.firstName_ = 'Panda';this._firstName = 'Panda';// goodthis.firstName = 'Panda'; 22.5 Don’t save references to this. Use arrow functions or Function#bind. jscs: disallowNodeTypes 12345678910111213141516171819202122// badfunction foo() &#123; const self = this; return function () &#123; console.log(self); &#125;;&#125;// badfunction foo() &#123; const that = this; return function () &#123; console.log(that); &#125;;&#125;// goodfunction foo() &#123; return () =&gt; &#123; console.log(this); &#125;;&#125; 22.6 A base filename should exactly match the name of its default export. 123456789101112131415161718192021222324252627282930// file 1 contentsclass CheckBox &#123; // ...&#125;export default CheckBox;// file 2 contentsexport default function fortyTwo() &#123; return 42; &#125;// file 3 contentsexport default function insideDirectory() &#123;&#125;// in some other file// badimport CheckBox from './checkBox'; // PascalCase import/export, camelCase filenameimport FortyTwo from './FortyTwo'; // PascalCase import/filename, camelCase exportimport InsideDirectory from './InsideDirectory'; // PascalCase import/filename, camelCase export// badimport CheckBox from './check_box'; // PascalCase import/export, snake_case filenameimport forty_two from './forty_two'; // snake_case import/filename, camelCase exportimport inside_directory from './inside_directory'; // snake_case import, camelCase exportimport index from './inside_directory/index'; // requiring the index file explicitlyimport insideDirectory from './insideDirectory/index'; // requiring the index file explicitly// goodimport CheckBox from './CheckBox'; // PascalCase export/import/filenameimport fortyTwo from './fortyTwo'; // camelCase export/import/filenameimport insideDirectory from './insideDirectory'; // camelCase export/import/directory name/implicit \"index\"// ^ supports both insideDirectory.js and insideDirectory/index.js 22.7 Use camelCase when you export-default a function. Your filename should be identical to your function’s name. 1234function makeStyleGuide() &#123;&#125;export default makeStyleGuide; 22.8 Use PascalCase when you export a constructor / class / singleton / function library / bare object. 123456const AirbnbStyleGuide = &#123; es6: &#123; &#125;&#125;;export default AirbnbStyleGuide; ⬆ back to top Accessors 23.1 Accessor functions for properties are not required. 23.2 Do not use JavaScript getters/setters as they cause unexpected side effects and are harder to test, maintain, and reason about. Instead, if you do make accessor functions, use getVal() and setVal(‘hello’). 123456789101112131415161718192021// badclass Dragon &#123; get age() &#123; // ... &#125; set age(value) &#123; // ... &#125;&#125;// goodclass Dragon &#123; getAge() &#123; // ... &#125; setAge(value) &#123; // ... &#125;&#125; 23.3 If the property/method is a boolean, use isVal() or hasVal(). 123456789// badif (!dragon.age()) &#123; return false;&#125;// goodif (!dragon.hasAge()) &#123; return false;&#125; 23.4 It’s okay to create get() and set() functions, but be consistent. 1234567891011121314class Jedi &#123; constructor(options = &#123;&#125;) &#123; const lightsaber = options.lightsaber || 'blue'; this.set('lightsaber', lightsaber); &#125; set(key, val) &#123; this[key] = val; &#125; get(key) &#123; return this[key]; &#125;&#125; ⬆ back to top Events 24.1 When attaching data payloads to events (whether DOM events or something more proprietary like Backbone events), pass a hash instead of a raw value. This allows a subsequent contributor to add more data to the event payload without finding and updating every handler for the event. For example, instead of: 12345678// bad$(this).trigger('listingUpdated', listing.id);...$(this).on('listingUpdated', (e, listingId) =&gt; &#123; // do something with listingId&#125;); prefer: 12345678// good$(this).trigger('listingUpdated', &#123; listingId: listing.id &#125;);...$(this).on('listingUpdated', (e, data) =&gt; &#123; // do something with data.listingId&#125;); ⬆ back to top jQuery 25.1 Prefix jQuery object variables with a $. jscs: requireDollarBeforejQueryAssignment 12345678// badconst sidebar = $('.sidebar');// goodconst $sidebar = $('.sidebar');// goodconst $sidebarBtn = $('.sidebar-btn'); 25.2 Cache jQuery lookups. 12345678910111213141516171819202122// badfunction setSidebar() &#123; $('.sidebar').hide(); // ...stuff... $('.sidebar').css(&#123; 'background-color': 'pink' &#125;);&#125;// goodfunction setSidebar() &#123; const $sidebar = $('.sidebar'); $sidebar.hide(); // ...stuff... $sidebar.css(&#123; 'background-color': 'pink' &#125;);&#125; 25.3 For DOM queries use Cascading $(&#39;.sidebar ul&#39;) or parent &gt; child $(&#39;.sidebar &gt; ul&#39;). jsPerf 25.4 Use find with scoped jQuery object queries. 1234567891011121314// bad$('ul', '.sidebar').hide();// bad$('.sidebar').find('ul').hide();// good$('.sidebar ul').hide();// good$('.sidebar &gt; ul').hide();// good$sidebar.find('ul').hide(); ⬆ back to top ECMAScript 5 Compatibility 26.1 Refer to Kangax‘s ES5 compatibility table. ⬆ back to top ECMAScript 6 Styles 27.1 This is a collection of links to the various ES6 features. Arrow Functions Classes Object Shorthand Object Concise Object Computed Properties Template Strings Destructuring Default Parameters Rest Array Spreads Let and Const Iterators and Generators Modules ⬆ back to top Testing 28.1 Yup. 123function foo() &#123; return true;&#125; 28.2 No, but seriously: Whichever testing framework you use, you should be writing tests! Strive to write many small pure functions, and minimize where mutations occur. Be cautious about stubs and mocks - they can make your tests more brittle. We primarily use mocha at Airbnb. tape is also used occasionally for small, separate modules. 100% test coverage is a good goal to strive for, even if it’s not always practical to reach it. Whenever you fix a bug, write a regression test. A bug fixed without a regression test is almost certainly going to break again in the future. ⬆ back to top Performance On Layout &amp; Web Performance String vs Array Concat Try/Catch Cost In a Loop Bang Function jQuery Find vs Context, Selector innerHTML vs textContent for script text Long String Concatenation Are Javascript functions like map(), reduce(), and filter() optimized for traversing arrays? Loading… ⬆ back to top ResourcesLearning ES6 Draft ECMA 2015 (ES6) Spec ExploringJS ES6 Compatibility Table Comprehensive Overview of ES6 Features Read This Standard ECMA-262 Tools Code Style Linters ESlint - Airbnb Style .eslintrc JSHint - Airbnb Style .jshintrc JSCS - Airbnb Style Preset Other Style Guides Google JavaScript Style Guide jQuery Core Style Guidelines Principles of Writing Consistent, Idiomatic JavaScript Other Styles Naming this in nested functions - Christian Johansen Conditional Callbacks - Ross Allen Popular JavaScript Coding Conventions on Github - JeongHoon Byun Multiple var statements in JavaScript, not superfluous - Ben Alman Further Reading Understanding JavaScript Closures - Angus Croll Basic JavaScript for the impatient programmer - Dr. Axel Rauschmayer You Might Not Need jQuery - Zack Bloom &amp; Adam Schwartz ES6 Features - Luke Hoban Frontend Guidelines - Benjamin De Cock Books JavaScript: The Good Parts - Douglas Crockford JavaScript Patterns - Stoyan Stefanov Pro JavaScript Design Patterns - Ross Harmes and Dustin Diaz High Performance Web Sites: Essential Knowledge for Front-End Engineers - Steve Souders Maintainable JavaScript - Nicholas C. Zakas JavaScript Web Applications - Alex MacCaw Pro JavaScript Techniques - John Resig Smashing Node.js: JavaScript Everywhere - Guillermo Rauch Secrets of the JavaScript Ninja - John Resig and Bear Bibeault Human JavaScript - Henrik Joreteg Superhero.js - Kim Joar Bekkelund, Mads Mobæk, &amp; Olav Bjorkoy JSBooks - Julien Bouquillon Third Party JavaScript - Ben Vinegar and Anton Kovalyov Effective JavaScript: 68 Specific Ways to Harness the Power of JavaScript - David Herman Eloquent JavaScript - Marijn Haverbeke You Don’t Know JS: ES6 &amp; Beyond - Kyle Simpson Blogs DailyJS JavaScript Weekly JavaScript, JavaScript… Bocoup Weblog Adequately Good NCZOnline Perfection Kills Ben Alman Dmitry Baranovskiy Dustin Diaz nettuts Podcasts JavaScript Jabber ⬆ back to top In the Wild This is a list of organizations that are using this style guide. Send us a pull request and we’ll add you to the list. 4Catalyzer: 4Catalyzer/javascript Aan Zee: AanZee/javascript Adult Swim: adult-swim/javascript Airbnb: airbnb/javascript Apartmint: apartmint/javascript Ascribe: ascribe/javascript Avalara: avalara/javascript Avant: avantcredit/javascript Billabong: billabong/javascript Bisk: bisk/javascript Blendle: blendle/javascript Brainshark: brainshark/javascript Chartboost: ChartBoost/javascript-style-guide ComparaOnline: comparaonline/javascript Compass Learning: compasslearning/javascript-style-guide DailyMotion: dailymotion/javascript DoSomething: DoSomething/eslint-config Digitpaint digitpaint/javascript Ecosia: ecosia/javascript Evernote: evernote/javascript-style-guide Evolution Gaming: evolution-gaming/javascript EvozonJs: evozonjs/javascript ExactTarget: ExactTarget/javascript Expensify Expensify/Style-Guide Flexberry: Flexberry/javascript-style-guide Gawker Media: gawkermedia/javascript General Electric: GeneralElectric/javascript GoodData: gooddata/gdc-js-style Grooveshark: grooveshark/javascript How About We: howaboutwe/javascript Huballin: huballin/javascript HubSpot: HubSpot/javascript Hyper: hyperoslo/javascript-playbook InfoJobs: InfoJobs/JavaScript-Style-Guide Intent Media: intentmedia/javascript Jam3: Jam3/Javascript-Code-Conventions JeopardyBot: kesne/jeopardy-bot JSSolutions: JSSolutions/javascript KickorStick: kickorstick/javascript Kinetica Solutions: kinetica/javascript Mighty Spring: mightyspring/javascript MinnPost: MinnPost/javascript MitocGroup: MitocGroup/javascript ModCloth: modcloth/javascript Money Advice Service: moneyadviceservice/javascript Muber: muber/javascript National Geographic: natgeo/javascript National Park Service: nationalparkservice/javascript Nimbl3: nimbl3/javascript Orion Health: orionhealth/javascript OutBoxSoft: OutBoxSoft/javascript Peerby: Peerby/javascript Razorfish: razorfish/javascript-style-guide reddit: reddit/styleguide/javascript React: /facebook/react/blob/master/CONTRIBUTING.md#style-guide REI: reidev/js-style-guide Ripple: ripple/javascript-style-guide SeekingAlpha: seekingalpha/javascript-style-guide Shutterfly: shutterfly/javascript Springload: springload/javascript StratoDem Analytics: stratodem/javascript StudentSphere: studentsphere/javascript SysGarage: sysgarage/javascript-style-guide Syzygy Warsaw: syzygypl/javascript Target: target/javascript TheLadders: TheLadders/javascript The Nerdery: thenerdery/javascript-standards T4R Technology: T4R-Technology/javascript VoxFeed: VoxFeed/javascript-style-guide WeBox Studio: weboxstudio/javascript Weggo: Weggo/javascript Zillow: zillow/javascript ZocDoc: ZocDoc/javascript ⬆ back to top Translation This style guide is also available in other languages: Brazilian Portuguese: armoucar/javascript-style-guide Bulgarian: borislavvv/javascript Catalan: fpmweb/javascript-style-guide Chinese (Simplified): sivan/javascript-style-guide Chinese (Traditional): jigsawye/javascript French: nmussy/javascript-style-guide German: timofurrer/javascript-style-guide Italian: sinkswim/javascript-style-guide Japanese: mitsuruog/javascript-style-guide Korean: tipjs/javascript-style-guide Polish: mjurczyk/javascript Russian: uprock/javascript Spanish: paolocarrasco/javascript-style-guide Thai: lvarayut/javascript-style-guide Vietnam: giangpii/javascript-style-guide The JavaScript Style Guide Guide Reference Chat With Us About JavaScript Find us on gitter. Contributors View Contributors License(The MIT License) Copyright (c) 2014-2016 Airbnb Permission is hereby granted, free of charge, to any person obtaininga copy of this software and associated documentation files (the‘Software’), to deal in the Software without restriction, includingwithout limitation the rights to use, copy, modify, merge, publish,distribute, sublicense, and/or sell copies of the Software, and topermit persons to whom the Software is furnished to do so, subject tothe following conditions: The above copyright notice and this permission notice shall beincluded in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED ‘AS IS’, WITHOUT WARRANTY OF ANY KIND,EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OFMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANYCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THESOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. ⬆ back to top AmendmentsWe encourage you to fork this guide and change the rules to fit your team’s style guide. Below, you may list some amendments to the style guide. This allows you to periodically update your style guide without having to deal with merge conflicts. };","categories":[{"name":"前端","slug":"前端","permalink":"http://bangwu.github.io/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://bangwu.github.io/tags/JavaScript/"}]}]}